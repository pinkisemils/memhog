FROM frolvlad/alpine-gcc
RUN mkdir -p /opt/memoryhog
RUN echo '#include <stdlib.h>' >> /opt/memoryhog/main.c
RUN echo '#include <unistd.h>' >> /opt/memoryhog/main.c
RUN echo '#include <stdio.h>' >> /opt/memoryhog/main.c
RUN echo '#include <stdbool.h>' >> /opt/memoryhog/main.c
RUN echo '#include <errno.h>' >> /opt/memoryhog/main.c
RUN echo '#include <sys/time.h>' >> /opt/memoryhog/main.c
RUN echo '#include <sys/resource.h>' >> /opt/memoryhog/main.c
RUN echo '/*w*/  long DEFAULT_LIMIT = 128; long DEFAULT_INCREMENT = 8; bool DEFAULT_SHOULD_STOP = false;  size_t env_to_sizet(char* env_var, long def) {     char* input = getenv(env_var);     if (input == NULL)     {         return def;     }      char* parse_end;     long retval = strtol(input, &parse_end, 10);     if (retval < 1 || parse_end == input)     {         fprintf(stderr, "Value %s of env var %s is invalid, using default value instead\n", input, env_var);         return def;     }      return (size_t)retval; }  void print_curr_mem_usage() {     struct rusage usg;     int err_code;     if ((err_code = getrusage(RUSAGE_SELF, &usg)) != 0)     {         fprintf(stderr, "getrusage failed with %d\n", err_code);         return;     }     fprintf(stdout, "ru_maxrss: %ldmb\n",             usg.ru_maxrss / 1024); }  int loop(size_t limit, size_t increment, bool should_stop) {     size_t current_usage = 0;     char* data;     while(limit > current_usage)     {         if ((data = malloc(1024 * 1024 * increment)) == NULL)         {             fprintf(stderr, "failed to malloc %ldMB more at %ld\n", increment, current_usage);             return -1;         }         for (int i=0; i<1024 * 1024 * increment; ++i)         {             data[i] = 1;         }         print_curr_mem_usage();          current_usage += increment;         sleep(1);     }     fprintf(stdout, "Will stop hogging memory now, currently hogged %ld\n", current_usage);     while (!should_stop)     {         sleep(1);     }     return 0; }  int main() {     size_t limit = env_to_sizet("MEMORY_LIMIT", DEFAULT_LIMIT);;     size_t increment = env_to_sizet("MEMORY_INCREMENT", DEFAULT_INCREMENT);     bool should_stop = !(getenv("SHOULD_CONTINUE") != NULL);      printf("limit: %ld\n", limit);     printf("increment: %ld\n", increment);     printf("should_stop: %s\n", should_stop ? "true" : "false");      return loop(limit, increment, should_stop); } ' >> /opt/memoryhog/main.c
RUN cd /opt/memoryhog/ && gcc -Wall -O3 main.c -o memoryhog
CMD ["/opt/memoryhog/memoryhog"]